
                    Sqlite Undo

What is it?
-----------

sqlite-undo is a A loadable extension for sqlite with the aim of 
providing "drop in" undo/redo functionality for databases used by 
single user applications or possibly multi-user applications
where users use separate data sets.

Many of the design ideas were cribbed from:

http://www.sqlite.org/cvstrac/wiki?p=UndoRedo

The incredibly awesome sqlite database lives here:

http://www.sqlite.org


The Latest Version
------------------

Details of the latest version can be found on the Sqlite Undo
Extension sourceforge project page:

https://sourceforge.net/projects/sqlite-undo/


Documentation
-------------

The shared library sqlite-undo.so is loaded using sqlite's
load_extension function. See the sqlite documentation at 
http://www.sqlite.org/lang_corefunc.html for further 
information.

At the time of writing the syntax for loading the module using
SQL on Linux is:

SELECT load_extension('/path/to/sqlite-undo.so');

When loaded it creates the following temporary objects on the
current database connection:

_undo
A temporary table to store the undo/redo log

_undo_stack
A temporary view containing the bounds of individual undoable
transactions in _undo

_undo_stack_top
A temporary view which returns the transaction at the top of
_undo_stack

_redo_stack
The same as _undo_stack, but for redoable transactions

_redo_stack_top
The same as _undo_stack_top, but for redoable transactions

_redo_row_ids
A temporary view which lists all the rowids related to redoable
transactions.

The following functions are also created:

undoable_table('[table]', [UpdateTriggerType])
This function creates temporary triggers which record the
query needed to undo or redo changed made against [table]
in the temporary table _undo.

[table] is a text string and therefore must be enclosed within
quotes - see "Usage example" below.

[UpdateTriggerType] determines how UPDATE triggers are created
and must be a value of 0, 1 or 2.

A value of 0 means that no tiggers will be created, therefore
UPDATE statements will not be undoable.

A value of 1 means that one trigger will be created to handle
updates to the entire row of data. So if only one column is
updated _undo will contain an update statement that updates
every column in the row, whether changed or not. Use this if
your application mostly updates the entire row with one
statement.

A value of 2 means that there will be one trigger created for
each non-primary key column. Use this if your application
mostly updates one column at a time.

Usage example:

SELECT undoable_table('MyUndoableTable', 1);


undoable('[sql]')
Execute [sql] and make it undoable.

All undoable queries must be executed using this function or
between undoable_begin() and undoable_end() functions below.

[sql] is passed directly to sqlite3_exec().

[sql] is a text string and therefore must be enclosed in
quotes. This has the side effect of requiring two quotes
adjacent to each other if a quote character is required in
the sql.

BEGIN, COMMIT and ROLLBACK statements are used internally in
the function so as sqlite does not allow nested transactions
you should not include any BEGIN, COMMIT or ROLLBACK statements
in[sql]. If a ROLLBACK occurs, perhaps as the result of a
trigger, then the error message "A rollback occurred" is 
returned. Any other error is an error code returned by
an sqlite3_exec() call.

On success, this function returns the following text string:

UNDO=[int]
REDO=[int]

The UNDO and REDO values are the number of transactions in
the respective stacks. This is returned so, for instance,
a GUI can enable or disable undo and redo buttons.

Usage example:

SELECT undoable('INSERT INTO MyUndoableTable(data) VALUES(''MyData'')');


undoable_begin()
[sql1]
...
[sqlN]
undoable_end()
These are an alternative to using undoable('[sql]'). Any sql
executed between a call to undoable_begin() and a call to 
undoable_end() will be considered a single undoable transaction
and will be undone or redone with a single call to undo() or
redo(). As with undoable('[SQL]') BEGIN, COMMIT and ROLLBACK 
statments should not be used between calls to these two functions.

undoable_end() returns the following text string on success:

UNDO=[int]
REDO=[int]

The UNDO and REDO values are the number of transactions in
the respective stacks. This is returned so, for instance,
a GUI can enable or disable undo and redo buttons.

If a ROLLBACK occurs, perhaps as the result of a trigger,
then the error message "A rollback occurred" is returned
by undoable_end();

Any other error returned by either function is the error
code returned by an sqlite3_exec() call.

Usage example:

SELECT undoable_begin();
INSERT INTO MyUndoableTable(data) VALUES('data1');
INSERT INTO MyUndoableTable(data) VALUES('data2');
INSERT INTO MyUndoableTable(data) VALUES('data3');
INSERT INTO MyUndoableTable(data) VALUES('data4');
SELECT undoable_end();


undo()
redo()
These functions undo or redo the transaction at the top of 
the undo stack and redo stack respectively.

They both return NULL if there are no transactions in their
respective stacks or a text string like so if there is:

UNDO=[int]
REDO=[int]
SQL=[text]

The UNDO and REDO values are the number of transactions in
the respective stacks. They are returned so, for instance,
a GUI can enable or disable undo and redo buttons.

SQL is the actual sql that was undone or redone. This is
returned so, for instance - again, a GUI can parse it to
determine what to display on the screen.

Summary:

Database Objects:

TEMP TABLE _undo
TEMP VIEW _undo_stack
TEMP VIEW _undo_stack_top
TEMP VIEW _redo_stack
TEMP VIEW _redo_stack_top
TEMP VIEW _redo_row_ids

Functions:

undoable_table('[table]',[UndoTriggerType])
undoable('[sql]')
undoable_begin()
undoable_end()
undo()
redo()


Installation
------------

Please see the file called INSTALL.


Licensing
---------

Please see the file called LICENSE.
